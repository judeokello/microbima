# Data Model: M-Pesa Daraja IPN and STK Push Integration

**Feature**: M-Pesa Daraja IPN and STK Push Integration  
**Date**: 2025-01-27  
**Status**: Design Complete

## Overview

This feature extends the existing M-Pesa payment data model to support:
1. **IPN (Instant Payment Notification)** - Real-time payment notifications from M-Pesa
2. **STK Push Requests** - Agent-initiated payment requests
3. **Payment Source Tracking** - Distinguish between IPN and statement-sourced records
4. **STK Push to IPN Linking** - Automatic linking of STK Push requests to IPN transactions

## New Enums

### MpesaPaymentSource

**Purpose**: Classify payment records by data source

**Values**:
- `IPN` - Payment record created from real-time IPN notification
- `STATEMENT` - Payment record created from manual statement upload

**Location**: `apps/api/prisma/schema.prisma` (after `MpesaStatementReasonType` enum)

**Usage**: 
- Default value: `IPN` for new payment records
- Used in deduplication logic (statement uploads check for existing IPN records)
- Enables data quality tracking and reporting

### MpesaStkPushStatus

**Purpose**: Track STK Push request lifecycle

**Values**:
- `PENDING` - Request initiated, waiting for customer action
- `COMPLETED` - Customer completed payment successfully
- `FAILED` - Payment failed (customer declined, insufficient funds, etc.)
- `CANCELLED` - Customer cancelled the payment
- `EXPIRED` - Request expired (M-Pesa timeout)

**Location**: `apps/api/prisma/schema.prisma` (after `MpesaPaymentSource` enum)

**State Transitions**:
```
PENDING → COMPLETED (customer completes payment)
PENDING → FAILED (payment fails)
PENDING → CANCELLED (customer cancels)
PENDING → EXPIRED (timeout)
```

## New Models

### MpesaStkPushRequest

**Purpose**: Track agent-initiated STK Push payment requests

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | `String @id @default(uuid())` | Primary key, UUID, **auto-generated** | Auto-populated UUID, used as MerchantRequestID in Daraja API (do not provide on creation) |
| `checkoutRequestId` | `String? @db.VarChar(100)` | Unique, nullable | From Daraja STK Push response (maps from `CheckoutRequestID` in API response) |
| `phoneNumber` | `String @db.VarChar(20)` | Required | Customer phone number (normalized: 254XXXXXXXXX) |
| `amount` | `Decimal @db.Decimal(10, 2)` | Required | Transaction amount (1-70,000 KES) |
| `accountReference` | `String @db.VarChar(100)` | Required, indexed | Policy payment account number (BillRefNumber) |
| `transactionDesc` | `String? @db.VarChar(500)` | Optional | Transaction description |
| `status` | `MpesaStkPushStatus` | Default: PENDING | Request status |
| `resultCode` | `String? @db.VarChar(10)` | Optional | From STK Push callback |
| `resultDesc` | `String? @db.VarChar(500)` | Optional | From STK Push callback |
| `linkedTransactionId` | `String? @db.VarChar(100)` | Optional | TransID from IPN (when linked) |
| `initiatedBy` | `String?` | Optional | Agent/user ID who initiated |
| `initiatedAt` | `DateTime @default(now())` | Required | When STK Push was initiated |
| `completedAt` | `DateTime?` | Optional | When transaction completed |
| `createdAt` | `DateTime @default(now())` | Required | Record creation timestamp |
| `updatedAt` | `DateTime @updatedAt` | Required | Record update timestamp |

**Relations**:
- `transaction MpesaPaymentReportItem?` - One-to-one, nullable (linked payment record)

**Indexes**:
- `@@unique([checkoutRequestId])` - Unique checkout request ID (for callback lookup)
- `@@index([accountReference])` - For matching with IPN BillRefNumber
- `@@index([status, createdAt])` - For querying pending requests
- `@@index([phoneNumber])` - For matching with IPN MSISDN

**Table Name**: `mpesa_stk_push_requests`

**Validation Rules**:
- `id` is auto-generated by Prisma (UUID) - **do not provide on creation**
- `phoneNumber` must be normalized to international format (254XXXXXXXXX)
- `amount` must be between 1 and 70,000 KES
- `accountReference` must match existing policy payment account number
- `checkoutRequestId` must be unique if provided

**Relations**:
- `callbackResponses MpesaStkPushCallbackResponse[]` - One-to-many (all callback responses for this request)

### MpesaStkPushCallbackResponse

**Purpose**: Store all STK Push callback responses from M-Pesa for audit purposes. This enables tracking of all responses (success, timeout, cancelled, etc.) for audit trails and supports retry logic.

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | `String @id @default(uuid())` | Primary key, UUID, **auto-generated** | Auto-populated UUID |
| `mpesaStkPushRequestId` | `String @db.Uuid` | Required, FK | Foreign key to STK Push request |
| `resultCode` | `Int` | Required | M-Pesa result code (0 = success, non-zero = error/failure) |
| `resultDesc` | `String @db.VarChar(500)` | Required | Result description from M-Pesa (e.g., "No response from user.", "The service request is processed successfully.") |
| `callbackMetadata` | `String? @db.Text` | Optional | JSON string of CallbackMetadata (if available) |
| `receivedAt` | `DateTime @default(now())` | Required | When this callback was received (UTC) |
| `createdAt` | `DateTime @default(now())` | Required | Record creation timestamp (UTC) |

**Relations**:
- `mpesaStkPushRequest MpesaStkPushRequest` - Many-to-one, required (parent STK Push request)

**Indexes**:
- `@@index([mpesaStkPushRequestId])` - For querying all responses for a request
- `@@index([resultCode])` - For filtering by result code (e.g., all failures)
- `@@index([receivedAt])` - For querying by time range

**Table Name**: `mpesa_stk_push_callback_responses`

**Validation Rules**:
- `id` is auto-generated by Prisma (UUID) - **do not provide on creation**
- `mpesaStkPushRequestId` must reference an existing `MpesaStkPushRequest`
- `resultCode` is stored as integer (0 for success, non-zero for failures)
- All timestamps are stored in UTC

**Business Rules**:
- Every STK Push callback from M-Pesa (regardless of result code) MUST be stored in this table
- Multiple responses may exist for the same STK Push request (M-Pesa may send multiple callbacks)
- This table provides complete audit trail of all STK Push payment attempts

## Updated Models

### MpesaPaymentReportItem

**Purpose**: Store M-Pesa transaction records (extended to support IPN and STK Push linking)

**New Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `mpesaPaymentReportUploadId` | `String? @db.Uuid` | **Changed to nullable** | FK to upload (null for IPN records) |
| `msisdn` | `String? @db.VarChar(20)` | Optional, indexed | Customer phone number (normalized: 254XXXXXXXXX) |
| `firstName` | `String? @db.VarChar(100)` | Optional | Customer first name from IPN |
| `middleName` | `String? @db.VarChar(100)` | Optional | Customer middle name from IPN |
| `lastName` | `String? @db.VarChar(100)` | Optional | Customer last name from IPN |
| `source` | `MpesaPaymentSource` | Default: IPN | Data source (IPN or STATEMENT) |
| `businessShortCode` | `String? @db.VarChar(20)` | Optional | Business short code from IPN |
| `mpesaStkPushRequestId` | `String? @db.Uuid` | Optional, FK | Link to STK Push request |

**Updated Relations**:
- `mpesaPaymentReportUpload MpesaPaymentReportUpload?` - Changed to optional (nullable)
- `mpesaStkPushRequest MpesaStkPushRequest?` - New relation (one-to-one, nullable)

**New Indexes**:
- `@@index([transactionReference, source], name: "idx_transaction_reference_source")` - Composite index for deduplication
- `@@index([source], name: "idx_source")` - For filtering by source
- `@@index([accountNumber], name: "idx_account_number")` - For matching with STK Push requests

**Existing Indexes** (preserved):
- `@@index([transactionReference], name: "idx_transaction_reference")`
- `@@index([mpesaPaymentReportUploadId], name: "idx_mpesa_payment_report_upload_id")`

**Validation Rules**:
- `transactionReference` must be unique per source (IPN records can have same reference as statement records)
- `msisdn` must be normalized to international format (254XXXXXXXXX) if provided
- `source` defaults to `IPN` for new records
- `mpesaPaymentReportUploadId` is null for IPN records, required for STATEMENT records

## Entity Relationships

```
MpesaPaymentReportItem
├── mpesaPaymentReportUpload (optional, nullable)
│   └── MpesaPaymentReportUpload (one-to-many)
├── mpesaStkPushRequest (optional, nullable)
│   └── MpesaStkPushRequest (one-to-one)
└── source: MpesaPaymentSource (IPN | STATEMENT)

MpesaStkPushRequest
├── transaction (optional, nullable)
│   └── MpesaPaymentReportItem (one-to-one)
├── callbackResponses
│   └── MpesaStkPushCallbackResponse[] (one-to-many)
└── status: MpesaStkPushStatus (PENDING | COMPLETED | FAILED | CANCELLED | EXPIRED)

MpesaStkPushCallbackResponse
├── mpesaStkPushRequest (required)
│   └── MpesaStkPushRequest (many-to-one)
└── Stores all callback responses for audit purposes
```

## Data Flow

### IPN Processing Flow

1. M-Pesa sends IPN notification → `MpesaIpnController`
2. Validate and parse IPN payload
3. **Check for duplicate in `policy_payments`**: Check by `transactionReference` for idempotency
4. Check for existing record: `MpesaPaymentReportItem` where `transactionReference = TransID` AND `source = 'IPN'`
5. If exists: Update existing records in both tables (idempotent)
6. If not exists:
   - **Always create `MpesaPaymentReportItem`** with:
     - `source = 'IPN'`
     - `mpesaPaymentReportUploadId = null`
     - Customer data from IPN payload
     - `paidIn` set appropriately (all IPN transactions are incoming payments)
   - **Payment record creation logic** (based on STK Push match):
     - If matches COMPLETED STK Push: Create only `MpesaPaymentReportItem` (skip `policy_payments` to prevent duplicate)
     - If matches PENDING STK Push: Create records in both `MpesaPaymentReportItem` and `policy_payments`, update STK Push status
     - If doesn't match any STK Push: Validate using same logic as XLS statement processing, then create records in both tables
7. Attempt to link to STK Push request (matching logic: accountReference, normalized phone, exact amount, 24-hour window with 5-minute buffer, UTC calculations)
8. Return success to M-Pesa

### STK Push Initiation Flow

1. Agent initiates STK Push → `MpesaStkPushController`
2. Validate parameters (phone, amount, account reference)
3. Create `MpesaStkPushRequest` with `status = 'PENDING'` (id is auto-generated UUID by Prisma)
4. Use the auto-generated `MpesaStkPushRequest.id` as `MerchantRequestID` when calling M-Pesa Daraja API
5. Store `CheckoutRequestID` from M-Pesa API response in `checkoutRequestId` database field
6. Return STK Push request details (including the auto-generated `id`)

### Policy Creation and Activation Flow

1. **Policy Creation (Registration Flow)**:
   - Create policy with `status = 'PENDING_ACTIVATION'`
   - Set `startDate = NULL` and `endDate = NULL` (for both prepaid and postpaid schemes)
   - Generate policy number for prepaid schemes (postpaid schemes have `policyNumber = NULL` until activation)
   - Policy remains in `PENDING_ACTIVATION` status until first payment completes

2. **Policy Activation (First Payment)**:
   - When IPN or STK Push callback indicates payment completion for a policy with `status = 'PENDING_ACTIVATION'`:
     - Update `status = 'ACTIVE'`
     - Set `startDate = payment date` (UTC, start of day: 00:00:00)
     - Set `endDate = startDate + 1 year` (UTC, end of day: 23:59:59.999)
     - Create policy member records (principal and dependants)
   - If policy status is already `ACTIVE` or any other status (e.g., `SUSPENDED`, `TERMINATED`), do NOT change status
   - Activation is idempotent: If policy is already `ACTIVE`, skip activation

3. **Subsequent Payments**:
   - IPN notifications for policies that are already `ACTIVE` or in other statuses:
     - Create payment records normally
     - Do NOT change policy status
     - Do NOT modify `startDate` or `endDate`

### STK Push Callback Flow

1. M-Pesa sends callback → `MpesaStkPushController`
2. **Store callback response**: Store ALL callback responses (regardless of result code) in `MpesaStkPushCallbackResponse` table for audit purposes
3. Find `MpesaStkPushRequest` by `checkoutRequestId` field, matching `CheckoutRequestID` from M-Pesa callback payload
4. Update status based on `ResultCode`:
   - `ResultCode = 0` → `COMPLETED`
   - Otherwise → `FAILED` or `CANCELLED`
5. **Payment record creation** (only if status is COMPLETED):
   - Check for existing placeholder payment (`transactionReference` starts with `PENDING-STK-` and `actualPaymentDate = null`) for the same policy
   - If placeholder exists: Update placeholder with real transaction reference and payment date
   - If no placeholder exists: Create records in both `MpesaPaymentReportItem` and `policy_payments`
6. **Handle idempotency**: Check if payment records already exist (IPN may have arrived first) - handle idempotently
7. **Policy activation**: If policy status is `PENDING_ACTIVATION`, activate policy (set status to `ACTIVE`, set dates)
8. **TODO**: Handle status mismatch scenario (if IPN already processed and created payment records, but callback arrives with FAILED/CANCELLED - see deferred decision in spec.md)
9. Store `resultCode` and `resultDesc` in `MpesaStkPushRequest`
10. Set `completedAt` timestamp
11. Return success to M-Pesa

### STK Push to IPN Linking Flow

1. IPN notification received and processed
2. Extract matching criteria:
   - `accountReference` (BillRefNumber)
   - `phoneNumber` (MSISDN, normalized)
   - `amount` (exact match, 0.00 tolerance)
   - Time window (24 hours + 5-minute buffer from STK Push initiation, UTC calculations)
3. Query `MpesaStkPushRequest`:
   - `accountReference = BillRefNumber`
   - `phoneNumber = MSISDN` (normalized)
   - `amount = TransAmount` (exact match)
   - `status IN ['PENDING', 'COMPLETED']`
   - `initiatedAt` within last 24 hours + 5 minutes (UTC)
   - Order by `initiatedAt DESC` (most recent first)
4. **Handle multiple matches**: Use most recent match (first result from ordered query)
5. If match found:
   - **Payment record creation based on match status**:
     - If match is COMPLETED: Create only `MpesaPaymentReportItem` (skip `policy_payments`)
     - If match is PENDING: Create records in both tables, update STK Push status
   - Set `MpesaPaymentReportItem.mpesaStkPushRequestId = matchedRequest.id`
   - Set `MpesaStkPushRequest.linkedTransactionId = TransID`
6. If no match found: Track as metric (distinguish: no match attempted vs match attempted but failed)

### Statement Upload Deduplication Flow

1. Statement file uploaded → `MpesaPaymentsService`
2. For each transaction in statement:
   - Query: `MpesaPaymentReportItem` where `transactionReference = statement.transactionReference` AND `source = 'IPN'`
   - If IPN record exists: Skip, increment match counter
   - If no IPN record: Create new record with `source = 'STATEMENT'` and `mpesaPaymentReportUploadId = upload.id`
3. Return statistics: total items, matched IPN records, gaps filled

## Validation Rules

### Phone Number Normalization

**Rule**: All phone numbers must be normalized to international format `254XXXXXXXXX`

**Implementation**:
- Strip leading zeros
- Ensure country code (254) is present
- Remove any non-numeric characters
- Validate length (12 digits: 254 + 9 digits)

**Applied To**:
- `MpesaStkPushRequest.phoneNumber`
- `MpesaPaymentReportItem.msisdn`
- Matching operations between STK Push and IPN

### Amount Validation

**Rule**: STK Push amounts must be between 1 and 70,000 KES

**Applied To**:
- `MpesaStkPushRequest.amount` (on creation)
- STK Push to IPN matching (exact match, 0.00 tolerance)

### Transaction Reference Uniqueness

**Rule**: Transaction references must be unique per source

**Implementation**:
- Composite unique constraint: `[transactionReference, source]`
- Allows same transaction reference for IPN and STATEMENT records
- Prevents duplicate IPN records
- Prevents duplicate STATEMENT records

## Indexes and Performance

### Query Patterns

1. **IPN Deduplication**: `transactionReference + source` → Composite index
2. **STK Push Callback Lookup**: `checkoutRequestId` → Unique index
3. **STK Push to IPN Matching**: `accountReference + phoneNumber + amount + status + createdAt` → Multiple indexes
4. **Statement Deduplication**: `transactionReference + source = 'IPN'` → Composite index
5. **Pending STK Push Queries**: `status + createdAt` → Composite index

### Index Strategy

- **Unique indexes**: Prevent duplicates (`checkoutRequestId`)
- **Composite indexes**: Optimize common query patterns (`transactionReference + source`)
- **Single column indexes**: Support filtering and matching (`accountReference`, `phoneNumber`, `source`)
- **Covering indexes**: Support queries without table access (where possible)

## Migration Strategy

1. Create new enums (`MpesaPaymentSource`, `MpesaStkPushStatus`)
2. Create new tables (`mpesa_stk_push_requests`, `mpesa_stk_push_callback_responses`)
3. Alter existing table (`mpesa_payment_report_items`):
   - Make `mpesaPaymentReportUploadId` nullable
   - Add new columns (nullable initially)
   - Add new indexes
   - Add new foreign key constraint
4. Update existing records:
   - Set `source = 'STATEMENT'` for all existing records
   - Set `mpesaPaymentReportUploadId` for existing records (already set)
5. Verify data integrity

**Migration Command**: `npx prisma migrate dev --name add_mpesa_ipn_and_stk_push`

## Data Integrity Constraints

1. **Referential Integrity**: 
   - `MpesaPaymentReportItem.mpesaStkPushRequestId` → `MpesaStkPushRequest.id` (optional)
   - `MpesaPaymentReportItem.mpesaPaymentReportUploadId` → `MpesaPaymentReportUpload.id` (optional)
   - `MpesaStkPushCallbackResponse.mpesaStkPushRequestId` → `MpesaStkPushRequest.id` (required, cascade delete)

2. **Business Rules**:
   - IPN records must have `mpesaPaymentReportUploadId = null`
   - STATEMENT records must have `mpesaPaymentReportUploadId != null`
   - STK Push requests can link to at most one payment record
   - Payment records can link to at most one STK Push request

3. **Uniqueness**:
   - `checkoutRequestId` must be unique (if provided)
   - `transactionReference + source` must be unique per source

