import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Customer, CustomerData } from '../entities/customer.entity';
import { PartnerCustomer, PartnerCustomerData } from '../entities/partner-customer.entity';
import { CustomerMapper } from '../mappers/customer.mapper';
import { PartnerCustomerMapper } from '../mappers/partner-customer.mapper';
import { CreatePrincipalMemberRequestDto } from '../dto/principal-member/create-principal-member-request.dto';
import { CreatePrincipalMemberResponseDto } from '../dto/principal-member/create-principal-member-response.dto';
import { PrincipalMemberDto } from '../dto/principal-member/principal-member.dto';

/**
 * Customer Service
 * 
 * Handles all customer-related business logic with proper partner scoping
 * Ensures that partners can only access their own customers
 * 
 * Features:
 * - Customer creation with partner relationship
 * - Customer retrieval scoped to partner
 * - Partner-customer relationship management
 * - Business validation and error handling
 */
@Injectable()
export class CustomerService {
  private readonly logger = new Logger(CustomerService.name);

  constructor(private readonly prismaService: PrismaService) {}

  /**
   * Create a new customer with partner relationship
   * @param createRequest - Customer creation request
   * @param partnerId - Partner ID from API key validation
   * @param correlationId - Correlation ID for tracing
   * @param skipPartnerValidation - Skip partner validation if already validated (e.g., by API key middleware)
   * @returns Customer creation response
   */
  async createCustomer(
    createRequest: CreatePrincipalMemberRequestDto,
    partnerId: number,
    correlationId: string,
    skipPartnerValidation: boolean = false
  ): Promise<CreatePrincipalMemberResponseDto> {
    this.logger.log(`[${correlationId}] Creating customer for partner ${partnerId}`);

    try {
      // Validate partner exists and is active (skip if already validated by middleware)
      if (!skipPartnerValidation) {
        const partner = await this.prismaService.partner.findFirst({
          where: {
            id: partnerId,
            isActive: true,
          },
        });

        if (!partner) {
          throw new BadRequestException('Partner not found or inactive');
        }
      }

      // Check if partner-customer relationship already exists
      this.logger.log(`[${correlationId}] Checking for existing partner customer: partnerId=${partnerId}, partnerCustomerId=${createRequest.principalMember.partnerCustomerId}`);
      const existingPartnerCustomer = await this.prismaService.partnerCustomer.findFirst({
        where: {
          partnerId: partnerId,
          partnerCustomerId: createRequest.principalMember.partnerCustomerId,
        },
      });

      if (existingPartnerCustomer) {
        throw new BadRequestException('Customer with this partner customer ID already exists');
      }

      // Create customer entity
      const customerEntity = CustomerMapper.fromPrincipalMemberDto(
        createRequest.principalMember,
        Number(partnerId)
      );

      // Validate customer entity
      const validationResult = customerEntity.validateBeforeSave();
      if (!validationResult.valid) {
        throw new BadRequestException(validationResult.errors.join(', '));
      }

      // Create customer in database
      const createdCustomer = await this.prismaService.customer.create({
        data: {
          firstName: customerEntity.firstName,
          middleName: customerEntity.middleName,
          lastName: customerEntity.lastName,
          email: customerEntity.email,
          phoneNumber: customerEntity.phoneNumber,
          dateOfBirth: customerEntity.dateOfBirth,
          gender: customerEntity.gender,
          idType: customerEntity.idType,
          idNumber: customerEntity.idNumber,
          status: customerEntity.status,
          onboardingStep: customerEntity.onboardingStep,
          createdByPartnerId: partnerId,
        },
      });

      // Create partner-customer relationship
      const partnerCustomerEntity = new PartnerCustomer({
        id: 0, // Will be generated by database
        partnerId: partnerId,
        customerId: createdCustomer.id,
        partnerCustomerId: createRequest.principalMember.partnerCustomerId,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Validate partner-customer entity
      const partnerCustomerValidation = partnerCustomerEntity.validateBeforeSave();
      if (!partnerCustomerValidation.valid) {
        // Rollback customer creation
        await this.prismaService.customer.delete({
          where: { id: createdCustomer.id },
        });
        throw new BadRequestException(partnerCustomerValidation.errors.join(', '));
      }

      const createdPartnerCustomer = await this.prismaService.partnerCustomer.create({
        data: {
          partnerId: partnerCustomerEntity.partnerId,
          customerId: partnerCustomerEntity.customerId,
          partnerCustomerId: partnerCustomerEntity.partnerCustomerId,
        },
      });

      // Create customer entity from database result
      const customer = Customer.fromPrismaData(createdCustomer);

      this.logger.log(`[${correlationId}] Customer created successfully: ${customer.id}`);

      // Return response using mapper
      return CustomerMapper.toCreatePrincipalMemberResponseDto(
        customer,
        createRequest.principalMember.partnerCustomerId,
        correlationId
      );
    } catch (error) {
      this.logger.error(`[${correlationId}] Error creating customer: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get customer by ID scoped to partner
   * @param customerId - Customer ID
   * @param partnerId - Partner ID from API key validation
   * @param correlationId - Correlation ID for tracing
   * @returns Customer data
   */
  async getCustomerById(
    customerId: string,
    partnerId: number,
    correlationId: string
  ): Promise<PrincipalMemberDto> {
    this.logger.log(`[${correlationId}] Getting customer ${customerId} for partner ${partnerId}`);

    try {
      // Get customer with partner relationship validation
      const customer = await this.prismaService.customer.findFirst({
        where: {
          id: customerId,
          createdByPartnerId: partnerId,
          partnerCustomers: {
            some: {
              partnerId: partnerId,
            },
          },
        },
      });

      if (!customer) {
        throw new NotFoundException('Customer not found or not accessible to this partner');
      }

      // Create customer entity
      const customerEntity = Customer.fromPrismaData(customer);

      this.logger.log(`[${correlationId}] Customer retrieved successfully: ${customerId}`);

      // Return customer data using mapper
      return CustomerMapper.toPrincipalMemberDto(customerEntity);
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting customer: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get all customers for a partner
   * @param partnerId - Partner ID from API key validation
   * @param correlationId - Correlation ID for tracing
   * @param page - Page number (default: 1)
   * @param limit - Items per page (default: 10, max: 100)
   * @returns Paginated customer list
   */
  async getCustomersByPartner(
    partnerId: number,
    correlationId: string,
    page: number = 1,
    limit: number = 10
  ): Promise<{
    customers: PrincipalMemberDto[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    this.logger.log(`[${correlationId}] Getting customers for partner ${partnerId}, page ${page}, limit ${limit}`);

    try {
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedLimit = Math.min(100, Math.max(1, limit));
      const skip = (validatedPage - 1) * validatedLimit;

      // Get customers with partner relationship validation
      const [customers, total] = await Promise.all([
        this.prismaService.customer.findMany({
          where: {
            createdByPartnerId: partnerId,
            partnerCustomers: {
              some: {
                partnerId: partnerId,
              },
            },
          },
          skip,
          take: validatedLimit,
          orderBy: {
            createdAt: 'desc',
          },
        }),
        this.prismaService.customer.count({
          where: {
            createdByPartnerId: partnerId,
            partnerCustomers: {
              some: {
                partnerId: partnerId,
              },
            },
          },
        }),
      ]);

      // Convert to entities and DTOs
      const customerEntities = customers.map(customer => Customer.fromPrismaData(customer));
      const customerDtos = customerEntities.map(customer => CustomerMapper.toPrincipalMemberDto(customer));

      const totalPages = Math.ceil(total / validatedLimit);

      this.logger.log(`[${correlationId}] Retrieved ${customers.length} customers for partner ${partnerId}`);

      return {
        customers: customerDtos,
        pagination: {
          page: validatedPage,
          limit: validatedLimit,
          total,
          totalPages,
        },
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting customers: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Check if customer exists and is accessible to partner
   * @param customerId - Customer ID
   * @param partnerId - Partner ID
   * @returns boolean
   */
  async customerExistsForPartner(customerId: string, partnerId: number): Promise<boolean> {
    const customer = await this.prismaService.customer.findFirst({
      where: {
        id: customerId,
        createdByPartnerId: partnerId,
        partnerCustomers: {
          some: {
            partnerId: partnerId,
          },
        },
      },
    });

    return !!customer;
  }

  /**
   * Get customer count for partner
   * @param partnerId - Partner ID
   * @returns number of customers
   */
  async getCustomerCountForPartner(partnerId: number): Promise<number> {
    return this.prismaService.customer.count({
      where: {
        createdByPartnerId: partnerId,
        partnerCustomers: {
          some: {
            partnerId: partnerId,
          },
        },
      },
    });
  }

}
