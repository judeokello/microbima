import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { SupabaseService } from './supabase.service';
import { Partner, PartnerData } from '../entities/partner.entity';
import { PartnerApiKey, PartnerApiKeyData } from '../entities/partner-api-key.entity';
import { PartnerMapper } from '../mappers/partner.mapper';
import { PartnerApiKeyMapper } from '../mappers/partner-api-key.mapper';
import * as crypto from 'crypto';

/**
 * Partner Management Service
 *
 * Consolidated service for all partner-related operations including:
 * - Partner CRUD operations
 * - API key generation and management
 * - Partner validation and business logic
 *
 * Features:
 * - Partner creation and management
 * - API key generation with automatic deactivation
 * - Partner validation and error handling
 * - Business logic for partner operations
 */
@Injectable()
export class PartnerManagementService {
  private readonly logger = new Logger(PartnerManagementService.name);

  constructor(
    private readonly prismaService: PrismaService,
    private readonly supabaseService: SupabaseService
  ) {}

  // ==================== PARTNER OPERATIONS ====================

  /**
   * Create a new partner (idempotent operation)
   * @param partnerData - Partner creation data
   * @param correlationId - Correlation ID for tracing
   * @returns Object containing partner and whether it was created (true) or retrieved (false)
   */
  async createPartner(
    partnerData: {
      partnerName: string;
      website?: string;
      officeLocation?: string;
    },
    correlationId: string
  ): Promise<{ partner: Partner; wasCreated: boolean }> {
    this.logger.log(`[${correlationId}] Creating partner: ${partnerData.partnerName}`);

    try {
      // Check if partner with same name already exists (idempotent behavior)
      const existingPartner = await this.prismaService.partner.findFirst({
        where: {
          partnerName: partnerData.partnerName,
        },
      });

      if (existingPartner) {
        this.logger.log(`[${correlationId}] Partner already exists: ${existingPartner.partnerName} (ID: ${existingPartner.id})`);
        return { partner: Partner.fromPrismaData(existingPartner), wasCreated: false };
      }

      // Create partner entity
      const partnerEntity = new Partner({
        id: 0, // Will be generated by database
        partnerName: partnerData.partnerName,
        website: partnerData.website || null,
        officeLocation: partnerData.officeLocation || null,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: null,
        updatedBy: null,
      });

      // Validate partner entity
      const validationResult = partnerEntity.validateBeforeSave();
      if (!validationResult.valid) {
        throw new BadRequestException(validationResult.errors.join(', '));
      }

      // Create partner in database
      const createdPartner = await this.prismaService.partner.create({
        data: {
          partnerName: partnerEntity.partnerName,
          website: partnerEntity.website,
          officeLocation: partnerEntity.officeLocation,
          isActive: partnerEntity.isActive,
        },
      });

      // Create partner entity from database result
      const partner = Partner.fromPrismaData(createdPartner);

      this.logger.log(`[${correlationId}] Partner created successfully: ${partner.id}`);

      return { partner, wasCreated: true };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error creating partner: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get partner by ID
   * @param partnerId - Partner ID
   * @param correlationId - Correlation ID for tracing
   * @returns Partner data
   */
  async getPartnerById(
    partnerId: number,
    correlationId: string
  ): Promise<Partner> {
    this.logger.log(`[${correlationId}] Getting partner: ${partnerId}`);

    try {
      const partner = await this.prismaService.partner.findUnique({
        where: { id: partnerId },
      });

      if (!partner) {
        throw new NotFoundException('Partner not found');
      }

      const partnerEntity = Partner.fromPrismaData(partner);

      this.logger.log(`[${correlationId}] Partner retrieved successfully: ${partnerId}`);

      return partnerEntity;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting partner: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get all partners
   * @param correlationId - Correlation ID for tracing
   * @param page - Page number (default: 1)
   * @param limit - Items per page (default: 10, max: 100)
   * @returns Paginated partner list
   */
  async getPartners(
    correlationId: string,
    page: number = 1,
    limit: number = 10
  ): Promise<{
    partners: Partner[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    this.logger.log(`[${correlationId}] Getting partners, page ${page}, limit ${limit}`);

    try {
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedLimit = Math.min(100, Math.max(1, limit));
      const skip = (validatedPage - 1) * validatedLimit;

      // Get partners
      const [partners, total] = await Promise.all([
        this.prismaService.partner.findMany({
          skip,
          take: validatedLimit,
          orderBy: {
            createdAt: 'desc',
          },
        }),
        this.prismaService.partner.count(),
      ]);

      // Convert to entities
      const partnerEntities = partners.map(partner => Partner.fromPrismaData(partner));

      const totalPages = Math.ceil(total / validatedLimit);

      this.logger.log(`[${correlationId}] Retrieved ${partners.length} partners`);

      return {
        partners: partnerEntities,
        pagination: {
          page: validatedPage,
          limit: validatedLimit,
          total,
          totalPages,
        },
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting partners: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  // ==================== API KEY OPERATIONS ====================

  /**
   * Generate a new API key for a partner
   * @param partnerId - Partner ID
   * @param correlationId - Correlation ID for tracing
   * @returns Generated API key (plain text)
   */
  async generateApiKey(
    partnerId: number,
    correlationId: string
  ): Promise<{
    apiKey: string;
    partnerId: number;
    createdAt: Date;
  }> {
    this.logger.log(`[${correlationId}] Generating API key for partner: ${partnerId}`);

    try {
      // Validate partner exists and is active
      const partner = await this.prismaService.partner.findFirst({
        where: {
          id: partnerId,
          isActive: true,
        },
      });

      if (!partner) {
        throw new BadRequestException('Partner not found or inactive');
      }

      // Generate new API key
      const plainApiKey = this.generateSecureApiKey();
      const hashedApiKey = PartnerApiKey.hashApiKey(plainApiKey);

      // Use a transaction to ensure atomicity
      const result = await this.prismaService.$transaction(async (tx) => {
        // Delete any existing active API keys for this partner
        await tx.partnerApiKey.deleteMany({
          where: {
            partnerId: partnerId,
            isActive: true,
          },
        });

        // Create new API key
        const createdApiKey = await tx.partnerApiKey.create({
          data: {
            partnerId: partnerId,
            apiKey: hashedApiKey,
            isActive: true,
          },
        });

        return createdApiKey;
      });

      const createdApiKey = result;

      this.logger.log(`[${correlationId}] API key generated successfully for partner: ${partnerId}`);

      return {
        apiKey: plainApiKey,
        partnerId: partnerId,
        createdAt: createdApiKey.createdAt,
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error generating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Validate API key and return partner information
   * @param apiKey - API key to validate
   * @param correlationId - Correlation ID for tracing
   * @returns Partner information if valid
   */
  async validateApiKey(
    apiKey: string,
    correlationId: string
  ): Promise<{
    valid: boolean;
    partnerId?: number;
    message: string;
  }> {
    this.logger.log(`[${correlationId}] Validating API key`);

    try {
      // Basic format validation
      if (!PartnerApiKey.validateApiKeyFormat(apiKey)) {
        return {
          valid: false,
          message: 'Invalid API key format',
        };
      }

      // Hash the API key for database lookup
      const hashedApiKey = PartnerApiKey.hashApiKey(apiKey);

      // Find the API key in the database
      const partnerApiKey = await this.prismaService.partnerApiKey.findFirst({
        where: {
          apiKey: hashedApiKey,
        },
        include: {
          partner: true,
        },
      });

      // Check if API key exists
      if (!partnerApiKey) {
        return {
          valid: false,
          message: 'Invalid API key',
        };
      }

      // Check if API key is active
      if (!partnerApiKey.isActive) {
        return {
          valid: false,
          message: 'API key is inactive',
        };
      }

      // Check if the partner is active
      if (!partnerApiKey.partner.isActive) {
        return {
          valid: false,
          message: 'Partner is inactive',
        };
      }

      // All validations passed
      return {
        valid: true,
        partnerId: partnerApiKey.partnerId,
        message: 'API key is valid',
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error validating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      return {
        valid: false,
        message: 'Error validating API key',
      };
    }
  }

  /**
   * Deactivate an API key
   * @param apiKey - API key to deactivate
   * @param correlationId - Correlation ID for tracing
   * @returns Success status
   */
  async deactivateApiKey(
    apiKey: string,
    correlationId: string
  ): Promise<boolean> {
    this.logger.log(`[${correlationId}] Deactivating API key`);

    try {
      const hashedApiKey = PartnerApiKey.hashApiKey(apiKey);

      const result = await this.prismaService.partnerApiKey.updateMany({
        where: {
          apiKey: hashedApiKey,
          isActive: true,
        },
        data: {
          isActive: false,
          updatedAt: new Date(),
        },
      });

      const success = result.count > 0;
      this.logger.log(`[${correlationId}] API key deactivation ${success ? 'successful' : 'failed'}`);

      return success;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error deactivating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Generate a secure API key
   * @returns Generated API key string
   */
  private generateSecureApiKey(): string {
    const randomBytes = crypto.randomBytes(32);
    const apiKey = randomBytes.toString('hex');

    // Add prefix for identification
    return `mb_${apiKey}`;
  }

  /**
   * Check if partner exists and is active
   * @param partnerId - Partner ID
   * @returns boolean
   */
  async partnerExistsAndActive(partnerId: number): Promise<boolean> {
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    return !!partner;
  }

  /**
   * Get partner's active API key count
   * @param partnerId - Partner ID
   * @returns number of active API keys
   */
  async getActiveApiKeyCount(partnerId: number): Promise<number> {
    return this.prismaService.partnerApiKey.count({
      where: {
        partnerId: partnerId,
        isActive: true,
      },
    });
  }

  // ==================== BRAND AMBASSADOR OPERATIONS ====================

  /**
   * Create a new Brand Ambassador for a partner
   * @param partnerId - Partner ID
   * @param brandAmbassadorData - Brand Ambassador data including user creation info
   * @param correlationId - Correlation ID for tracing
   * @returns Created Brand Ambassador
   */
  async createBrandAmbassador(
    partnerId: number,
    brandAmbassadorData: {
      email: string;
      password: string;
      firstName: string;
      lastName: string;
      roles: string[];
      phoneNumber?: string;
      perRegistrationRateCents: number;
      isActive?: boolean;
      createdBy?: string;
    },
    correlationId: string
  ) {
    this.logger.log(`[${correlationId}] Creating Brand Ambassador for partner ${partnerId}`);

    // Validate that partner exists and is active
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    if (!partner) {
      throw new NotFoundException(`Partner with ID ${partnerId} not found or inactive`);
    }

    // Combine first and last name into displayName
    const displayName = `${brandAmbassadorData.firstName} ${brandAmbassadorData.lastName}`.trim();

    // Step 1: Create Supabase user
    const userResult = await this.supabaseService.createUser({
      email: brandAmbassadorData.email,
      password: brandAmbassadorData.password,
      userMetadata: {
        roles: brandAmbassadorData.roles,
        partnerId: partnerId,
        displayName: displayName,
        phone: brandAmbassadorData.phoneNumber,
        perRegistrationRateCents: brandAmbassadorData.perRegistrationRateCents
      }
    });

    if (!userResult.success) {
      throw new BadRequestException(`Failed to create user: ${userResult.error}`);
    }

    const userId = userResult.data.id;

    // Check if Brand Ambassador already exists for this user (shouldn't happen, but safety check)
    const existingBA = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: userId,
      },
    });

    if (existingBA) {
      throw new BadRequestException('Brand Ambassador already exists for this user');
    }

    // Use createdBy from request if provided, otherwise use the new BA's userId
    const createdByUserId = brandAmbassadorData.createdBy || userId;

    // Step 2: Create the Brand Ambassador record
    const brandAmbassador = await this.prismaService.brandAmbassador.create({
      data: {
        userId: userId,
        partnerId: partnerId,
        displayName: displayName,
        phoneNumber: brandAmbassadorData.phoneNumber,
        perRegistrationRateCents: brandAmbassadorData.perRegistrationRateCents,
        isActive: brandAmbassadorData.isActive ?? true,
        createdBy: createdByUserId,
        updatedBy: createdByUserId,
      },
    });

    this.logger.log(`✅ Brand Ambassador created successfully: ${brandAmbassador.id}`);
    return brandAmbassador;
  }

  /**
   * Create a Brand Ambassador from an existing user
   * @param partnerId - Partner ID
   * @param brandAmbassadorData - Brand Ambassador data for existing user
   * @param correlationId - Correlation ID for tracing
   * @returns Created Brand Ambassador
   */
  async createBrandAmbassadorFromExistingUser(
    partnerId: number,
    brandAmbassadorData: {
      userId: string;
      displayName: string;
      phoneNumber?: string;
      perRegistrationRateCents: number;
      isActive?: boolean;
      createdBy?: string;
    },
    correlationId: string
  ) {
    this.logger.log(`[${correlationId}] Creating Brand Ambassador from existing user ${brandAmbassadorData.userId} for partner ${partnerId}`);

    // Validate that partner exists and is active
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    if (!partner) {
      throw new NotFoundException(`Partner with ID ${partnerId} not found or inactive`);
    }

    // Verify that the user exists in Supabase (optional check)
    try {
      const { data: user, error } = await this.supabaseService
        .getClient()
        .auth.admin.getUserById(brandAmbassadorData.userId);

      if (error || !user) {
        throw new BadRequestException(`User with ID ${brandAmbassadorData.userId} not found`);
      }
    } catch (error) {
      this.logger.warn(`[${correlationId}] Could not verify user existence in Supabase: ${error instanceof Error ? error.message : 'Unknown error'}`);
      // Continue anyway - the user might exist but we can't verify due to permissions
    }

    // Check if Brand Ambassador already exists for this user
    const existingBA = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: brandAmbassadorData.userId,
      },
    });

    if (existingBA) {
      throw new BadRequestException('Brand Ambassador already exists for this user');
    }

    // Use createdBy from request if provided, otherwise use the user's own ID
    const createdByUserId = brandAmbassadorData.createdBy || brandAmbassadorData.userId;

    // Create the Brand Ambassador record
    const brandAmbassador = await this.prismaService.brandAmbassador.create({
      data: {
        userId: brandAmbassadorData.userId,
        partnerId: partnerId,
        displayName: brandAmbassadorData.displayName,
        phoneNumber: brandAmbassadorData.phoneNumber,
        perRegistrationRateCents: brandAmbassadorData.perRegistrationRateCents,
        isActive: brandAmbassadorData.isActive ?? true,
        createdBy: createdByUserId,
        updatedBy: createdByUserId,
      },
    });

    this.logger.log(`✅ Brand Ambassador created successfully from existing user: ${brandAmbassador.id}`);
    return brandAmbassador;
  }

  /**
   * Get all Brand Ambassadors
   * @param correlationId - Correlation ID for tracing
   * @param page - Page number (default: 1)
   * @param limit - Items per page (default: 10, max: 100)
   * @returns Paginated brand ambassadors list
   */
  async getAllBrandAmbassadors(
    correlationId: string,
    page: number = 1,
    limit: number = 10
  ): Promise<{
    brandAmbassadors: any[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    this.logger.log(`[${correlationId}] Getting all Brand Ambassadors, page ${page}, limit ${limit}`);

    try {
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedLimit = Math.min(100, Math.max(1, limit));
      const skip = (validatedPage - 1) * validatedLimit;

      // Get brand ambassadors with partner information
      const [brandAmbassadors, total] = await Promise.all([
        this.prismaService.brandAmbassador.findMany({
          skip,
          take: validatedLimit,
          include: {
            partner: {
              select: {
                id: true,
                partnerName: true,
                isActive: true,
              },
            },
          },
          orderBy: {
            createdAt: 'desc',
          },
        }),
        this.prismaService.brandAmbassador.count(),
      ]);

      const totalPages = Math.ceil(total / validatedLimit);

      this.logger.log(`[${correlationId}] Retrieved ${brandAmbassadors.length} brand ambassadors`);

      return {
        brandAmbassadors: brandAmbassadors.map(ba => ({
          id: ba.id,
          userId: ba.userId,
          partnerId: ba.partnerId,
          displayName: ba.displayName,
          phoneNumber: ba.phoneNumber,
          perRegistrationRateCents: ba.perRegistrationRateCents,
          isActive: ba.isActive,
          createdAt: ba.createdAt,
          updatedAt: ba.updatedAt,
          partner: ba.partner,
        })),
        pagination: {
          page: validatedPage,
          limit: validatedLimit,
          total,
          totalPages,
        },
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting brand ambassadors: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get Brand Ambassador by User ID
   * @param userId - Supabase User ID
   * @returns Brand Ambassador information
   */
  async getBrandAmbassadorByUserId(userId: string) {
    this.logger.log(`Getting Brand Ambassador for user: ${userId}`);

    const brandAmbassador = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: userId,
        isActive: true,
      },
      include: {
        partner: {
          select: {
            id: true,
            partnerName: true,
            isActive: true,
          },
        },
      },
    });

    if (!brandAmbassador) {
      throw new NotFoundException('Brand Ambassador not found or inactive');
    }

    this.logger.log(`✅ Brand Ambassador found: ${brandAmbassador.id}`);
    return {
      id: brandAmbassador.id,
      userId: brandAmbassador.userId,
      partnerId: brandAmbassador.partnerId,
      displayName: brandAmbassador.displayName,
      phoneNumber: brandAmbassador.phoneNumber,
      perRegistrationRateCents: brandAmbassador.perRegistrationRateCents,
      isActive: brandAmbassador.isActive,
      partner: brandAmbassador.partner,
    };
  }
}
