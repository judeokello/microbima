import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Partner, PartnerData } from '../entities/partner.entity';
import { PartnerApiKey, PartnerApiKeyData } from '../entities/partner-api-key.entity';
import { PartnerMapper } from '../mappers/partner.mapper';
import { PartnerApiKeyMapper } from '../mappers/partner-api-key.mapper';

/**
 * Partner Management Service
 * 
 * Consolidated service for all partner-related operations including:
 * - Partner CRUD operations
 * - API key generation and management
 * - Partner validation and business logic
 * 
 * Features:
 * - Partner creation and management
 * - API key generation with automatic deactivation
 * - Partner validation and error handling
 * - Business logic for partner operations
 */
@Injectable()
export class PartnerManagementService {
  private readonly logger = new Logger(PartnerManagementService.name);

  constructor(private readonly prismaService: PrismaService) {}

  // ==================== PARTNER OPERATIONS ====================

  /**
   * Create a new partner
   * @param partnerData - Partner creation data
   * @param correlationId - Correlation ID for tracing
   * @returns Created partner
   */
  async createPartner(
    partnerData: {
      partnerName: string;
      website?: string;
      officeLocation?: string;
    },
    correlationId: string
  ): Promise<Partner> {
    this.logger.log(`[${correlationId}] Creating partner: ${partnerData.partnerName}`);

    try {
      // Create partner entity
      const partnerEntity = new Partner({
        id: 0, // Will be generated by database
        partnerName: partnerData.partnerName,
        website: partnerData.website || null,
        officeLocation: partnerData.officeLocation || null,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: null,
        updatedBy: null,
      });

      // Validate partner entity
      const validationResult = partnerEntity.validateBeforeSave();
      if (!validationResult.valid) {
        throw new BadRequestException(validationResult.errors.join(', '));
      }

      // Create partner in database
      const createdPartner = await this.prismaService.partner.create({
        data: {
          partnerName: partnerEntity.partnerName,
          website: partnerEntity.website,
          officeLocation: partnerEntity.officeLocation,
          isActive: partnerEntity.isActive,
        },
      });

      // Create partner entity from database result
      const partner = Partner.fromPrismaData(createdPartner);

      this.logger.log(`[${correlationId}] Partner created successfully: ${partner.id}`);

      return partner;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error creating partner: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get partner by ID
   * @param partnerId - Partner ID
   * @param correlationId - Correlation ID for tracing
   * @returns Partner data
   */
  async getPartnerById(
    partnerId: number,
    correlationId: string
  ): Promise<Partner> {
    this.logger.log(`[${correlationId}] Getting partner: ${partnerId}`);

    try {
      const partner = await this.prismaService.partner.findUnique({
        where: { id: partnerId },
      });

      if (!partner) {
        throw new NotFoundException('Partner not found');
      }

      const partnerEntity = Partner.fromPrismaData(partner);

      this.logger.log(`[${correlationId}] Partner retrieved successfully: ${partnerId}`);

      return partnerEntity;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting partner: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get all partners
   * @param correlationId - Correlation ID for tracing
   * @param page - Page number (default: 1)
   * @param limit - Items per page (default: 10, max: 100)
   * @returns Paginated partner list
   */
  async getPartners(
    correlationId: string,
    page: number = 1,
    limit: number = 10
  ): Promise<{
    partners: Partner[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    this.logger.log(`[${correlationId}] Getting partners, page ${page}, limit ${limit}`);

    try {
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedLimit = Math.min(100, Math.max(1, limit));
      const skip = (validatedPage - 1) * validatedLimit;

      // Get partners
      const [partners, total] = await Promise.all([
        this.prismaService.partner.findMany({
          skip,
          take: validatedLimit,
          orderBy: {
            createdAt: 'desc',
          },
        }),
        this.prismaService.partner.count(),
      ]);

      // Convert to entities
      const partnerEntities = partners.map(partner => Partner.fromPrismaData(partner));

      const totalPages = Math.ceil(total / validatedLimit);

      this.logger.log(`[${correlationId}] Retrieved ${partners.length} partners`);

      return {
        partners: partnerEntities,
        pagination: {
          page: validatedPage,
          limit: validatedLimit,
          total,
          totalPages,
        },
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting partners: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  // ==================== API KEY OPERATIONS ====================

  /**
   * Generate a new API key for a partner
   * @param partnerId - Partner ID
   * @param correlationId - Correlation ID for tracing
   * @returns Generated API key (plain text)
   */
  async generateApiKey(
    partnerId: number,
    correlationId: string
  ): Promise<{
    apiKey: string;
    partnerId: number;
    createdAt: Date;
  }> {
    this.logger.log(`[${correlationId}] Generating API key for partner: ${partnerId}`);

    try {
      // Validate partner exists and is active
      const partner = await this.prismaService.partner.findFirst({
        where: {
          id: partnerId,
          isActive: true,
        },
      });

      if (!partner) {
        throw new BadRequestException('Partner not found or inactive');
      }

      // Generate new API key
      const plainApiKey = this.generateSecureApiKey();
      const hashedApiKey = PartnerApiKey.hashApiKey(plainApiKey);

      // Deactivate any existing active API keys for this partner
      await this.prismaService.partnerApiKey.updateMany({
        where: {
          partnerId: partnerId,
          isActive: true,
        },
        data: {
          isActive: false,
          updatedAt: new Date(),
        },
      });

      // Create new API key
      const createdApiKey = await this.prismaService.partnerApiKey.create({
        data: {
          partnerId: partnerId,
          apiKey: hashedApiKey,
          isActive: true,
        },
      });

      this.logger.log(`[${correlationId}] API key generated successfully for partner: ${partnerId}`);

      return {
        apiKey: plainApiKey,
        partnerId: partnerId,
        createdAt: createdApiKey.createdAt,
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error generating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Validate API key and return partner information
   * @param apiKey - API key to validate
   * @param correlationId - Correlation ID for tracing
   * @returns Partner information if valid
   */
  async validateApiKey(
    apiKey: string,
    correlationId: string
  ): Promise<{
    valid: boolean;
    partnerId?: number;
    message: string;
  }> {
    this.logger.log(`[${correlationId}] Validating API key`);

    try {
      // Basic format validation
      if (!PartnerApiKey.validateApiKeyFormat(apiKey)) {
        return {
          valid: false,
          message: 'Invalid API key format',
        };
      }

      // Hash the API key for database lookup
      const hashedApiKey = PartnerApiKey.hashApiKey(apiKey);

      // Find the API key in the database
      const partnerApiKey = await this.prismaService.partnerApiKey.findFirst({
        where: {
          apiKey: hashedApiKey,
        },
        include: {
          partner: true,
        },
      });

      // Check if API key exists
      if (!partnerApiKey) {
        return {
          valid: false,
          message: 'Invalid API key',
        };
      }

      // Check if API key is active
      if (!partnerApiKey.isActive) {
        return {
          valid: false,
          message: 'API key is inactive',
        };
      }

      // Check if the partner is active
      if (!partnerApiKey.partner.isActive) {
        return {
          valid: false,
          message: 'Partner is inactive',
        };
      }

      // All validations passed
      return {
        valid: true,
        partnerId: partnerApiKey.partnerId,
        message: 'API key is valid',
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error validating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      return {
        valid: false,
        message: 'Error validating API key',
      };
    }
  }

  /**
   * Deactivate an API key
   * @param apiKey - API key to deactivate
   * @param correlationId - Correlation ID for tracing
   * @returns Success status
   */
  async deactivateApiKey(
    apiKey: string,
    correlationId: string
  ): Promise<boolean> {
    this.logger.log(`[${correlationId}] Deactivating API key`);

    try {
      const hashedApiKey = PartnerApiKey.hashApiKey(apiKey);

      const result = await this.prismaService.partnerApiKey.updateMany({
        where: {
          apiKey: hashedApiKey,
          isActive: true,
        },
        data: {
          isActive: false,
          updatedAt: new Date(),
        },
      });

      const success = result.count > 0;
      this.logger.log(`[${correlationId}] API key deactivation ${success ? 'successful' : 'failed'}`);

      return success;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error deactivating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Generate a secure API key
   * @returns Generated API key string
   */
  private generateSecureApiKey(): string {
    const crypto = require('crypto');
    const randomBytes = crypto.randomBytes(32);
    const apiKey = randomBytes.toString('hex');
    
    // Add prefix for identification
    return `mb_${apiKey}`;
  }

  /**
   * Check if partner exists and is active
   * @param partnerId - Partner ID
   * @returns boolean
   */
  async partnerExistsAndActive(partnerId: number): Promise<boolean> {
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    return !!partner;
  }

  /**
   * Get partner's active API key count
   * @param partnerId - Partner ID
   * @returns number of active API keys
   */
  async getActiveApiKeyCount(partnerId: number): Promise<number> {
    return this.prismaService.partnerApiKey.count({
      where: {
        partnerId: partnerId,
        isActive: true,
      },
    });
  }
}
