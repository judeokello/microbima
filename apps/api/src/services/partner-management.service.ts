import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { SupabaseService } from './supabase.service';
import { Prisma } from '@prisma/client';
import { Partner } from '../entities/partner.entity';
import { PartnerApiKey } from '../entities/partner-api-key.entity';
import * as crypto from 'crypto';

/**
 * Partner Management Service
 *
 * Consolidated service for all partner-related operations including:
 * - Partner CRUD operations
 * - API key generation and management
 * - Partner validation and business logic
 *
 * Features:
 * - Partner creation and management
 * - API key generation with automatic deactivation
 * - Partner validation and error handling
 * - Business logic for partner operations
 */
@Injectable()
export class PartnerManagementService {
  private readonly logger = new Logger(PartnerManagementService.name);

  constructor(
    private readonly prismaService: PrismaService,
    private readonly supabaseService: SupabaseService
  ) {}

  // ==================== PARTNER OPERATIONS ====================

  /**
   * Create a new partner (idempotent operation)
   * @param partnerData - Partner creation data
   * @param correlationId - Correlation ID for tracing
   * @returns Object containing partner and whether it was created (true) or retrieved (false)
   */
  async createPartner(
    partnerData: {
      partnerName: string;
      website?: string;
      officeLocation?: string;
    },
    correlationId: string
  ): Promise<{ partner: Partner; wasCreated: boolean }> {
    this.logger.log(`[${correlationId}] Creating partner: ${partnerData.partnerName}`);

    try {
      // Check if partner with same name already exists (idempotent behavior)
      const existingPartner = await this.prismaService.partner.findFirst({
        where: {
          partnerName: partnerData.partnerName,
        },
      });

      if (existingPartner) {
        this.logger.log(`[${correlationId}] Partner already exists: ${existingPartner.partnerName} (ID: ${existingPartner.id})`);
        return { partner: Partner.fromPrismaData(existingPartner), wasCreated: false };
      }

      // Create partner entity
      const partnerEntity = new Partner({
        id: 0, // Will be generated by database
        partnerName: partnerData.partnerName,
        website: partnerData.website ?? null,
        officeLocation: partnerData.officeLocation ?? null,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: null,
        updatedBy: null,
      });

      // Validate partner entity
      const validationResult = partnerEntity.validateBeforeSave();
      if (!validationResult.valid) {
        throw new BadRequestException(validationResult.errors.join(', '));
      }

      // Create partner in database
      const createdPartner = await this.prismaService.partner.create({
        data: {
          partnerName: partnerEntity.partnerName,
          website: partnerEntity.website,
          officeLocation: partnerEntity.officeLocation,
          isActive: partnerEntity.isActive,
        },
      });

      // Create partner entity from database result
      const partner = Partner.fromPrismaData(createdPartner);

      this.logger.log(`[${correlationId}] Partner created successfully: ${partner.id}`);

      return { partner, wasCreated: true };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error creating partner: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get partner by ID
   * @param partnerId - Partner ID
   * @param correlationId - Correlation ID for tracing
   * @returns Partner data
   */
  async getPartnerById(
    partnerId: number,
    correlationId: string
  ): Promise<Partner> {
    this.logger.log(`[${correlationId}] Getting partner: ${partnerId}`);

    try {
      const partner = await this.prismaService.partner.findUnique({
        where: { id: partnerId },
      });

      if (!partner) {
        throw new NotFoundException('Partner not found');
      }

      const partnerEntity = Partner.fromPrismaData(partner);

      this.logger.log(`[${correlationId}] Partner retrieved successfully: ${partnerId}`);

      return partnerEntity;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting partner: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Get all partners
   * @param correlationId - Correlation ID for tracing
   * @param page - Page number (default: 1)
   * @param limit - Items per page (default: 10, max: 100)
   * @returns Paginated partner list
   */
  async getPartners(
    correlationId: string,
    page: number = 1,
    limit: number = 10
  ): Promise<{
    partners: Partner[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    this.logger.log(`[${correlationId}] Getting partners, page ${page}, limit ${limit}`);

    try {
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedLimit = Math.min(100, Math.max(1, limit));
      const skip = (validatedPage - 1) * validatedLimit;

      // Get partners
      const [partners, total] = await Promise.all([
        this.prismaService.partner.findMany({
          skip,
          take: validatedLimit,
          orderBy: {
            createdAt: 'desc',
          },
        }),
        this.prismaService.partner.count(),
      ]);

      // Convert to entities
      const partnerEntities = partners.map(partner => Partner.fromPrismaData(partner));

      const totalPages = Math.ceil(total / validatedLimit);

      this.logger.log(`[${correlationId}] Retrieved ${partners.length} partners`);

      return {
        partners: partnerEntities,
        pagination: {
          page: validatedPage,
          limit: validatedLimit,
          total,
          totalPages,
        },
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting partners: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  // ==================== API KEY OPERATIONS ====================

  /**
   * Generate a new API key for a partner
   * @param partnerId - Partner ID
   * @param correlationId - Correlation ID for tracing
   * @returns Generated API key (plain text)
   */
  async generateApiKey(
    partnerId: number,
    correlationId: string
  ): Promise<{
    apiKey: string;
    partnerId: number;
    createdAt: Date;
  }> {
    this.logger.log(`[${correlationId}] Generating API key for partner: ${partnerId}`);

    try {
      // Validate partner exists and is active
      const partner = await this.prismaService.partner.findFirst({
        where: {
          id: partnerId,
          isActive: true,
        },
      });

      if (!partner) {
        throw new BadRequestException('Partner not found or inactive');
      }

      // Generate new API key
      const plainApiKey = this.generateSecureApiKey();
      const hashedApiKey = PartnerApiKey.hashApiKey(plainApiKey);

      // Use a transaction to ensure atomicity
      const result = await this.prismaService.$transaction(async (tx: Prisma.TransactionClient) => {
        // Delete any existing active API keys for this partner
        await tx.partnerApiKey.deleteMany({
          where: {
            partnerId: partnerId,
            isActive: true,
          },
        });

        // Create new API key
        const createdApiKey = await tx.partnerApiKey.create({
          data: {
            partnerId: partnerId,
            apiKey: hashedApiKey,
            isActive: true,
          },
        });

        return createdApiKey;
      });

      const createdApiKey = result;

      this.logger.log(`[${correlationId}] API key generated successfully for partner: ${partnerId}`);

      return {
        apiKey: plainApiKey,
        partnerId: partnerId,
        createdAt: createdApiKey.createdAt,
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error generating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Validate API key and return partner information
   * @param apiKey - API key to validate
   * @param correlationId - Correlation ID for tracing
   * @returns Partner information if valid
   */
  async validateApiKey(
    apiKey: string,
    correlationId: string
  ): Promise<{
    valid: boolean;
    partnerId?: number;
    message: string;
  }> {
    this.logger.log(`[${correlationId}] Validating API key`);

    try {
      // Basic format validation
      if (!PartnerApiKey.validateApiKeyFormat(apiKey)) {
        return {
          valid: false,
          message: 'Invalid API key format',
        };
      }

      // Hash the API key for database lookup
      const hashedApiKey = PartnerApiKey.hashApiKey(apiKey);

      // Find the API key in the database
      const partnerApiKey = await this.prismaService.partnerApiKey.findFirst({
        where: {
          apiKey: hashedApiKey,
        },
        include: {
          partner: true,
        },
      });

      // Check if API key exists
      if (!partnerApiKey) {
        return {
          valid: false,
          message: 'Invalid API key',
        };
      }

      // Check if API key is active
      if (!partnerApiKey.isActive) {
        return {
          valid: false,
          message: 'API key is inactive',
        };
      }

      // Check if the partner is active
      if (!partnerApiKey.partner.isActive) {
        return {
          valid: false,
          message: 'Partner is inactive',
        };
      }

      // All validations passed
      return {
        valid: true,
        partnerId: partnerApiKey.partnerId,
        message: 'API key is valid',
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error validating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      return {
        valid: false,
        message: 'Error validating API key',
      };
    }
  }

  /**
   * Deactivate an API key
   * @param apiKey - API key to deactivate
   * @param correlationId - Correlation ID for tracing
   * @returns Success status
   */
  async deactivateApiKey(
    apiKey: string,
    correlationId: string
  ): Promise<boolean> {
    this.logger.log(`[${correlationId}] Deactivating API key`);

    try {
      const hashedApiKey = PartnerApiKey.hashApiKey(apiKey);

      const result = await this.prismaService.partnerApiKey.updateMany({
        where: {
          apiKey: hashedApiKey,
          isActive: true,
        },
        data: {
          isActive: false,
          updatedAt: new Date(),
        },
      });

      const success = result.count > 0;
      this.logger.log(`[${correlationId}] API key deactivation ${success ? 'successful' : 'failed'}`);

      return success;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error deactivating API key: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  // ==================== UTILITY METHODS ====================

  /**
   * Generate a secure API key
   * @returns Generated API key string
   */
  private generateSecureApiKey(): string {
    const randomBytes = crypto.randomBytes(32);
    const apiKey = randomBytes.toString('hex');

    // Add prefix for identification
    return `mb_${apiKey}`;
  }

  /**
   * Check if partner exists and is active
   * @param partnerId - Partner ID
   * @returns boolean
   */
  async partnerExistsAndActive(partnerId: number): Promise<boolean> {
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    return !!partner;
  }

  /**
   * Get partner's active API key count
   * @param partnerId - Partner ID
   * @returns number of active API keys
   */
  async getActiveApiKeyCount(partnerId: number): Promise<number> {
    return this.prismaService.partnerApiKey.count({
      where: {
        partnerId: partnerId,
        isActive: true,
      },
    });
  }

  // ==================== BRAND AMBASSADOR OPERATIONS ====================

  /**
   * Create a new Brand Ambassador for a partner
   * @param partnerId - Partner ID
   * @param brandAmbassadorData - Brand Ambassador data including user creation info
   * @param correlationId - Correlation ID for tracing
   * @returns Created Brand Ambassador
   */
  async createBrandAmbassador(
    partnerId: number,
    brandAmbassadorData: {
      email: string;
      password: string;
      firstName: string;
      lastName: string;
      roles: string[];
      phoneNumber?: string;
      perRegistrationRateCents: number;
      isActive?: boolean;
      createdBy?: string;
    },
    correlationId: string
  ) {
    this.logger.log(`[${correlationId}] Creating Brand Ambassador for partner ${partnerId}`);

    // Validate that partner exists and is active
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    if (!partner) {
      throw new NotFoundException(`Partner with ID ${partnerId} not found or inactive`);
    }

    // Combine first and last name into displayName
    const displayName = `${brandAmbassadorData.firstName} ${brandAmbassadorData.lastName}`.trim();

    // Step 1: Create Supabase user
    // Only store roles in user metadata - other data is stored in brand_ambassadors table
    const userResult = await this.supabaseService.createUser({
      email: brandAmbassadorData.email,
      password: brandAmbassadorData.password,
      userMetadata: {
        roles: brandAmbassadorData.roles,
      }
    });

    if (!userResult.success) {
      throw new BadRequestException(`Failed to create user: ${userResult.error}`);
    }

    if (!userResult.data || typeof userResult.data !== 'object' || !('id' in userResult.data)) {
      throw new BadRequestException('Invalid user data returned from Supabase');
    }

    const userId = (userResult.data as { id: string }).id;

    // Check if Brand Ambassador already exists for this user (shouldn't happen, but safety check)
    const existingBA = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: userId,
      },
    });

    if (existingBA) {
      throw new BadRequestException('Brand Ambassador already exists for this user');
    }

    // Use createdBy from request if provided, otherwise use the new BA's userId
    const createdByUserId = brandAmbassadorData.createdBy ?? userId;

    // Step 2: Create the Brand Ambassador record
    const brandAmbassador = await this.prismaService.brandAmbassador.create({
      data: {
        userId: userId,
        partnerId: partnerId,
        displayName: displayName,
        phoneNumber: brandAmbassadorData.phoneNumber,
        perRegistrationRateCents: brandAmbassadorData.perRegistrationRateCents,
        isActive: brandAmbassadorData.isActive ?? true,
        createdBy: createdByUserId,
        updatedBy: createdByUserId,
      },
    });

    this.logger.log(`✅ Brand Ambassador created successfully: ${brandAmbassador.id}`);
    return brandAmbassador;
  }

  /**
   * Create a Brand Ambassador from an existing user
   * @param partnerId - Partner ID
   * @param brandAmbassadorData - Brand Ambassador data for existing user
   * @param correlationId - Correlation ID for tracing
   * @returns Created Brand Ambassador
   */
  async createBrandAmbassadorFromExistingUser(
    partnerId: number,
    brandAmbassadorData: {
      userId: string;
      displayName: string;
      phoneNumber?: string;
      perRegistrationRateCents: number;
      isActive?: boolean;
      createdBy?: string;
    },
    correlationId: string
  ) {
    this.logger.log(`[${correlationId}] Creating Brand Ambassador from existing user ${brandAmbassadorData.userId} for partner ${partnerId}`);

    // Validate that partner exists and is active
    const partner = await this.prismaService.partner.findFirst({
      where: {
        id: partnerId,
        isActive: true,
      },
    });

    if (!partner) {
      throw new NotFoundException(`Partner with ID ${partnerId} not found or inactive`);
    }

    // Verify that the user exists in Supabase (optional check)
    try {
      const { data: user, error } = await this.supabaseService
        .getClient()
        .auth.admin.getUserById(brandAmbassadorData.userId);

      if (error || !user) {
        throw new BadRequestException(`User with ID ${brandAmbassadorData.userId} not found`);
      }
    } catch (error) {
      this.logger.warn(`[${correlationId}] Could not verify user existence in Supabase: ${error instanceof Error ? error.message : 'Unknown error'}`);
      // Continue anyway - the user might exist but we can't verify due to permissions
    }

    // Check if Brand Ambassador already exists for this user
    const existingBA = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: brandAmbassadorData.userId,
      },
    });

    if (existingBA) {
      throw new BadRequestException('Brand Ambassador already exists for this user');
    }

    // Use createdBy from request if provided, otherwise use the user's own ID
    const createdByUserId = brandAmbassadorData.createdBy ?? brandAmbassadorData.userId;

    // Create the Brand Ambassador record
    const brandAmbassador = await this.prismaService.brandAmbassador.create({
      data: {
        userId: brandAmbassadorData.userId,
        partnerId: partnerId,
        displayName: brandAmbassadorData.displayName,
        phoneNumber: brandAmbassadorData.phoneNumber,
        perRegistrationRateCents: brandAmbassadorData.perRegistrationRateCents,
        isActive: brandAmbassadorData.isActive ?? true,
        createdBy: createdByUserId,
        updatedBy: createdByUserId,
      },
    });

    this.logger.log(`✅ Brand Ambassador created successfully from existing user: ${brandAmbassador.id}`);
    return brandAmbassador;
  }

  /**
   * Get all Brand Ambassadors
   * @param correlationId - Correlation ID for tracing
   * @param page - Page number (default: 1)
   * @param limit - Items per page (default: 10, max: 100)
   * @returns Paginated brand ambassadors list
   */
  async getAllBrandAmbassadors(
    correlationId: string,
    page: number = 1,
    limit: number = 10
  ): Promise<{
    brandAmbassadors: Array<{
      id: string;
      userId: string;
      partnerId: number;
      displayName: string;
      phoneNumber?: string | null;
      email?: string | null;
      perRegistrationRateCents?: number | null;
      isActive: boolean;
      createdAt: Date;
      updatedAt: Date;
    }>;
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    this.logger.log(`[${correlationId}] Getting all Brand Ambassadors, page ${page}, limit ${limit}`);

    try {
      // Validate pagination parameters
      const validatedPage = Math.max(1, page);
      const validatedLimit = Math.min(100, Math.max(1, limit));
      const skip = (validatedPage - 1) * validatedLimit;

      // Get brand ambassadors with partner information
      const [brandAmbassadors, total] = await Promise.all([
        this.prismaService.brandAmbassador.findMany({
          skip,
          take: validatedLimit,
          include: {
            partner: {
              select: {
                id: true,
                partnerName: true,
                isActive: true,
              },
            },
          },
          orderBy: {
            createdAt: 'desc',
          },
        }),
        this.prismaService.brandAmbassador.count(),
      ]);

      const totalPages = Math.ceil(total / validatedLimit);

      this.logger.log(`[${correlationId}] Retrieved ${brandAmbassadors.length} brand ambassadors`);

      return {
        brandAmbassadors: brandAmbassadors.map(ba => ({
          id: ba.id,
          userId: ba.userId,
          partnerId: ba.partnerId,
          displayName: ba.displayName,
          phoneNumber: ba.phoneNumber,
          perRegistrationRateCents: ba.perRegistrationRateCents,
          isActive: ba.isActive,
          createdAt: ba.createdAt,
          updatedAt: ba.updatedAt,
          partner: ba.partner,
        })),
        pagination: {
          page: validatedPage,
          limit: validatedLimit,
          total,
          totalPages,
        },
      };
    } catch (error) {
      this.logger.error(`[${correlationId}] Error getting brand ambassadors: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }

  /**
   * Check Brand Ambassador active status by User ID
   * @param userId - Supabase User ID
   * @returns Brand Ambassador active status
   */
  async checkBrandAmbassadorActiveStatus(userId: string): Promise<{ isActive: boolean; exists: boolean }> {
    this.logger.log(`Checking Brand Ambassador active status for user: ${userId}`);

    const brandAmbassador = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: userId,
      },
      select: {
        isActive: true,
      },
    });

    if (!brandAmbassador) {
      this.logger.log(`Brand Ambassador not found for user: ${userId}`);
      return { isActive: false, exists: false };
    }

    this.logger.log(`Brand Ambassador status for user ${userId}: isActive=${brandAmbassador.isActive}`);
    return { isActive: brandAmbassador.isActive, exists: true };
  }

  /**
   * Get Brand Ambassador by User ID
   * @param userId - Supabase User ID
   * @returns Brand Ambassador information
   */
  async getBrandAmbassadorByUserId(userId: string) {
    this.logger.log(`Getting Brand Ambassador for user: ${userId}`);

    const brandAmbassador = await this.prismaService.brandAmbassador.findFirst({
      where: {
        userId: userId,
        isActive: true,
      },
      include: {
        partner: {
          select: {
            id: true,
            partnerName: true,
            isActive: true,
          },
        },
      },
    });

    if (!brandAmbassador) {
      throw new NotFoundException('Brand Ambassador not found or inactive');
    }

    this.logger.log(`✅ Brand Ambassador found: ${brandAmbassador.id}`);
    return {
      id: brandAmbassador.id,
      userId: brandAmbassador.userId,
      partnerId: brandAmbassador.partnerId,
      displayName: brandAmbassador.displayName,
      phoneNumber: brandAmbassador.phoneNumber,
      perRegistrationRateCents: brandAmbassador.perRegistrationRateCents,
      isActive: brandAmbassador.isActive,
      partner: brandAmbassador.partner,
    };
  }

  /**
   * Update a Brand Ambassador
   * @param id - Brand Ambassador ID
   * @param updateData - Update data
   * @param updatedByUserId - User ID of the admin performing the update
   * @param correlationId - Correlation ID for tracing
   * @returns Updated Brand Ambassador
   */
  async updateBrandAmbassador(
    id: string,
    updateData: {
      partnerId?: number;
      phoneNumber?: string;
      perRegistrationRateCents?: number;
      isActive?: boolean;
      roles?: string[];
    },
    updatedByUserId: string,
    correlationId: string
  ) {
    this.logger.log(`[${correlationId}] Updating Brand Ambassador: ${id}`);

    // Check if Brand Ambassador exists
    const existingBA = await this.prismaService.brandAmbassador.findUnique({
      where: { id },
    });

    if (!existingBA) {
      throw new NotFoundException(`Brand Ambassador with ID ${id} not found`);
    }

    // Validate partner if partnerId is being updated
    if (updateData.partnerId !== undefined) {
      const partner = await this.prismaService.partner.findFirst({
        where: {
          id: updateData.partnerId,
          isActive: true,
        },
      });

      if (!partner) {
        throw new NotFoundException(`Partner with ID ${updateData.partnerId} not found or inactive`);
      }
    }

    // Prepare update data (only include fields that are provided)
    const dataToUpdate: Prisma.BrandAmbassadorUpdateInput = {
      updatedBy: updatedByUserId,
    };

    if (updateData.partnerId !== undefined) {
      dataToUpdate.partner = {
        connect: { id: updateData.partnerId },
      };
    }

    if (updateData.phoneNumber !== undefined) {
      dataToUpdate.phoneNumber = updateData.phoneNumber || null;
    }

    if (updateData.perRegistrationRateCents !== undefined) {
      dataToUpdate.perRegistrationRateCents = updateData.perRegistrationRateCents;
    }

    if (updateData.isActive !== undefined) {
      dataToUpdate.isActive = updateData.isActive;
    }

    // Update the Brand Ambassador
    const updatedBA = await this.prismaService.brandAmbassador.update({
      where: { id },
      data: dataToUpdate,
      include: {
        partner: {
          select: {
            id: true,
            partnerName: true,
            isActive: true,
          },
        },
      },
    });

    // Update user metadata roles if provided
    if (updateData.roles !== undefined) {
      // Get current user metadata
      const { data: { user }, error: getUserError } = await this.supabaseService
        .getClient()
        .auth.admin.getUserById(existingBA.userId);

      if (getUserError || !user) {
        this.logger.warn(`[${correlationId}] Could not fetch user metadata for role update: ${getUserError?.message}`);
      } else {
        // Clean up metadata to only keep roles - remove other fields that are stored in DB
        const updatedMetadata = {
          roles: updateData.roles,
        };

        // Update user metadata with new roles
        const { error: updateMetadataError } = await this.supabaseService
          .getClient()
          .auth.admin.updateUserById(existingBA.userId, {
            user_metadata: updatedMetadata,
          });

        if (updateMetadataError) {
          this.logger.error(`[${correlationId}] Error updating user metadata: ${updateMetadataError.message}`);
          // Don't throw - BA update succeeded, role update is secondary
        } else {
          this.logger.log(`[${correlationId}] ✅ User roles updated successfully`);
        }
      }
    }

    this.logger.log(`[${correlationId}] ✅ Brand Ambassador updated successfully: ${updatedBA.id}`);
    return updatedBA;
  }

  /**
   * Get user metadata (roles) for a Brand Ambassador
   * @param baId - Brand Ambassador ID
   * @param correlationId - Correlation ID for tracing
   * @returns User roles array
   */
  async getBrandAmbassadorRoles(
    baId: string,
    correlationId: string
  ): Promise<string[]> {
    this.logger.log(`[${correlationId}] Getting roles for Brand Ambassador: ${baId}`);

    // Get Brand Ambassador to find userId
    const brandAmbassador = await this.prismaService.brandAmbassador.findUnique({
      where: { id: baId },
    });

    if (!brandAmbassador) {
      throw new NotFoundException(`Brand Ambassador with ID ${baId} not found`);
    }

    // Get user from Supabase
    const { data: { user }, error } = await this.supabaseService
      .getClient()
      .auth.admin.getUserById(brandAmbassador.userId);

    if (error || !user) {
      throw new NotFoundException(`User with ID ${brandAmbassador.userId} not found`);
    }

    const userMetadata = user.user_metadata ?? {};
    const roles = userMetadata.roles ?? [];

    this.logger.log(`[${correlationId}] ✅ Retrieved roles for Brand Ambassador: ${roles.join(', ')}`);
    return roles;
  }

  /**
   * Update Brand Ambassador password
   * @param baId - Brand Ambassador ID
   * @param password - New password
   * @param correlationId - Correlation ID for tracing
   * @returns Success status
   */
  async updateBrandAmbassadorPassword(
    baId: string,
    password: string,
    correlationId: string
  ) {
    this.logger.log(`[${correlationId}] Updating password for Brand Ambassador: ${baId}`);

    // Get Brand Ambassador to find userId
    const brandAmbassador = await this.prismaService.brandAmbassador.findUnique({
      where: { id: baId },
    });

    if (!brandAmbassador) {
      throw new NotFoundException(`Brand Ambassador with ID ${baId} not found`);
    }

    // Update password using Supabase admin API
    const { error } = await this.supabaseService
      .getClient()
      .auth.admin.updateUserById(brandAmbassador.userId, {
        password: password,
      });

    if (error) {
      this.logger.error(`[${correlationId}] Error updating password: ${error.message}`);
      throw new BadRequestException(`Failed to update password: ${error.message}`);
    }

    this.logger.log(`[${correlationId}] ✅ Password updated successfully for Brand Ambassador: ${baId}`);
    return { success: true };
  }

  /**
   * Clean up user metadata for all Brand Ambassadors
   * Removes duplicate fields (displayName, phone, partnerId, perRegistrationRateCents, email_verified)
   * and keeps only the roles array
   * @param correlationId - Correlation ID for tracing
   * @returns Number of users cleaned up
   */
  async cleanupBrandAmbassadorMetadata(correlationId: string): Promise<number> {
    this.logger.log(`[${correlationId}] Starting user metadata cleanup for Brand Ambassadors`);

    let cleanedCount = 0;

    try {
      // Get all Brand Ambassadors
      const brandAmbassadors = await this.prismaService.brandAmbassador.findMany({
        select: {
          id: true,
          userId: true,
        },
      });

      this.logger.log(`[${correlationId}] Found ${brandAmbassadors.length} Brand Ambassadors to process`);

      // Process each Brand Ambassador
      for (const ba of brandAmbassadors) {
        try {
          // Get current user from Supabase
          const { data: { user }, error: getUserError } = await this.supabaseService
            .getClient()
            .auth.admin.getUserById(ba.userId);

          if (getUserError || !user) {
            this.logger.warn(`[${correlationId}] Could not fetch user ${ba.userId}: ${getUserError?.message}`);
            continue;
          }

          const currentMetadata = user.user_metadata ?? {};
          const roles = currentMetadata.roles ?? [];

          // Check if cleanup is needed (if metadata has more than just roles)
          const hasExtraFields = Object.keys(currentMetadata).some(
            key => key !== 'roles'
          );

          if (!hasExtraFields) {
            // Already clean, skip
            continue;
          }

          // Clean metadata to only keep roles
          // Note: Supabase admin.updateUserById should replace user_metadata entirely
          // But we'll verify it worked by fetching the user again after update
          const cleanedMetadata = {
            roles: roles,
          };

          this.logger.log(`[${correlationId}] Updating metadata for user ${ba.userId} - current: ${JSON.stringify(currentMetadata)}, new: ${JSON.stringify(cleanedMetadata)}`);

          // Update user metadata
          const { error: updateError } = await this.supabaseService
            .getClient()
            .auth.admin.updateUserById(ba.userId, {
              user_metadata: cleanedMetadata,
            });

          if (updateError) {
            this.logger.error(`[${correlationId}] Error cleaning metadata for user ${ba.userId}: ${updateError.message}`);
            continue;
          }

          // Wait a moment for the update to propagate
          await new Promise(resolve => setTimeout(resolve, 100));

          // Verify the update actually worked by fetching the user again
          const { data: { user: verifyUser }, error: verifyError } = await this.supabaseService
            .getClient()
            .auth.admin.getUserById(ba.userId);

          if (verifyError || !verifyUser) {
            this.logger.error(`[${correlationId}] Could not verify update for user ${ba.userId}: ${verifyError?.message}`);
            continue;
          }

          const verifiedMetadata = verifyUser.user_metadata || {};
          const verifiedKeys = Object.keys(verifiedMetadata);
          const stillHasExtraFields = verifiedKeys.some(key => key !== 'roles');

          if (stillHasExtraFields) {
            this.logger.error(`[${correlationId}] ❌ Metadata update failed for user ${ba.userId} - still has extra fields: ${verifiedKeys.filter(k => k !== 'roles').join(', ')}. Current metadata: ${JSON.stringify(verifiedMetadata)}`);
            // Don't increment cleanedCount - the update didn't work
            continue;
          }

          cleanedCount++;
          this.logger.log(`[${correlationId}] ✅ Cleaned metadata for Brand Ambassador ${ba.id} (user ${ba.userId}) - verified: ${JSON.stringify(verifiedMetadata)}`);
        } catch (error) {
          this.logger.error(`[${correlationId}] Error processing Brand Ambassador ${ba.id}: ${error instanceof Error ? error.message : 'Unknown error'}`);
          continue;
        }
      }

      this.logger.log(`[${correlationId}] ✅ Metadata cleanup completed. Cleaned ${cleanedCount} of ${brandAmbassadors.length} users`);
      return cleanedCount;
    } catch (error) {
      this.logger.error(`[${correlationId}] Error during metadata cleanup: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? error.stack : undefined);
      throw error;
    }
  }
}
