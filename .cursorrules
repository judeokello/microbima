# MicroBima API Development Rules

## Error Handling Standards

### MANDATORY: Use Standardized Error Handling

When creating new endpoints or services, you MUST follow these error handling standards:

#### 1. Use Existing Error Codes
- **ALWAYS** check `src/enums/error-codes.enum.ts` for existing error codes before creating new ones
- **DO NOT** create overlapping or duplicate error codes
- **REUSE** existing codes like `VALIDATION_ERROR`, `DUPLICATE_EMAIL`, `NOT_FOUND`, etc.

#### 2. Use ValidationException for Validation Errors
```typescript
// ✅ CORRECT: Multiple field errors
const validationErrors: Record<string, string> = {};
if (existingEmail) validationErrors['email'] = 'Email already exists';
if (existingId) validationErrors['id_number'] = 'ID already exists';
throw ValidationException.withMultipleErrors(validationErrors);

// ✅ CORRECT: Single field error  
throw ValidationException.forField('email', 'Email already exists');
```

#### 3. Use "status" Field (NOT "statusCode")
- **ALWAYS** use `status` in error responses
- **NEVER** use `statusCode` in new code
- **UPDATE** any existing `statusCode` references to `status`

#### 4. Follow Standard Error Response Format
```json
{
  "error": {
    "code": "ERROR_CODE",
    "status": 422,
    "message": "Human-readable message",
    "details": { "field": "error message" },
    "correlationId": "req-12345",
    "timestamp": "2025-09-15T10:32:45.123Z",
    "path": "/api/v1/endpoint"
  }
}
```

#### 5. Pre-Save Validation Pattern
```typescript
// Collect ALL validation errors before throwing
const validationErrors: Record<string, string> = {};

// Entity validation
const entityValidation = entity.validateBeforeSave();
if (!entityValidation.valid) {
  // Add entity errors to validationErrors
}

// Database uniqueness checks
if (await this.checkEmailExists(email)) {
  validationErrors['email'] = 'Email already exists';
}

// Business rule validation
if (dateOfBirth > new Date()) {
  validationErrors['date_of_birth'] = 'Date cannot be in future';
}

// Throw ALL errors at once
if (Object.keys(validationErrors).length > 0) {
  throw ValidationException.withMultipleErrors(validationErrors);
}
```

### Available Error Codes by Category

#### Validation Errors (422)
- `VALIDATION_ERROR`, `DUPLICATE_EMAIL`, `DUPLICATE_ID_NUMBER`
- `INVALID_FORMAT`, `REQUIRED_FIELD_MISSING`, `FIELD_TOO_LONG`
- `INVALID_DATE`, `FUTURE_DATE_NOT_ALLOWED`, `INVALID_PHONE_NUMBER`

#### Client Errors (400)  
- `MALFORMED_REQUEST`, `INVALID_JSON`, `MISSING_REQUIRED_HEADERS`

#### Authentication Errors (401)
- `AUTHENTICATION_ERROR`, `INVALID_API_KEY`, `MISSING_API_KEY`

#### Authorization Errors (403)
- `AUTHORIZATION_ERROR`, `INSUFFICIENT_PERMISSIONS`

#### Not Found Errors (404)
- `NOT_FOUND`, `CUSTOMER_NOT_FOUND`, `PARTNER_NOT_FOUND`

#### Server Errors (500)
- `INTERNAL_SERVER_ERROR`, `DATABASE_ERROR`, `EXTERNAL_SERVICE_ERROR`

### Required Imports
```typescript
import { ValidationException } from '../exceptions/validation.exception';
import { ErrorCodes } from '../enums/error-codes.enum';
```

### Documentation Requirements
- Update `docs/development/error-handling-guide.md` with new error scenarios
- Add new error codes to the enum documentation
- Include error handling examples in endpoint documentation

## Database Standards

### Prisma Migration Standards (CRITICAL)
- **NEVER** use `npx prisma db push` for tracked databases (development, staging, production)
- **ALWAYS** use proper migrations to avoid drift:
  - Development: `npx prisma migrate dev --name descriptive_name` (creates and applies migration)
  - Production: `npx prisma migrate deploy` (applies pending migrations only)
- Only use `db push` for throwaway/prototype databases that don't need migration tracking
- All schema changes MUST go through Prisma migrations to maintain `_prisma_migrations` table accuracy

### Schema Updates
- Use nullable fields with unique constraints when appropriate
- Add compound unique constraints for business rules
- Create migrations for all schema changes

### Entity Validation
- Implement `validateBeforeSave()` method in all entities
- Return field-specific error messages
- Check business rules before database operations

## API Standards

### Response Format
- Use consistent response structure across all endpoints
- Include correlation IDs in all responses
- Use appropriate HTTP status codes
- Follow RESTful conventions

### Documentation
- Update Swagger documentation for new endpoints
- Include error response examples
- Document all possible error codes

## Testing Standards

### Error Testing
- Test all validation error scenarios
- Verify multiple field errors are returned together
- Test error response format consistency
- Include error code validation in tests

### Integration Testing
- Test error responses with proper headers
- Verify correlation IDs are included
- Test environment-specific behavior (stack traces in dev only)

## Code Review Checklist

Before submitting code, verify:
- [ ] Uses existing error codes from ErrorCodes enum
- [ ] Uses ValidationException for validation errors
- [ ] Uses "status" field (not "statusCode")
- [ ] Follows standard error response format
- [ ] Implements pre-save validation pattern
- [ ] Includes proper error handling tests
- [ ] Updates documentation if needed

## Timezone Handling Standards

### MANDATORY: Always Use UTC for Date/Time Operations

The database stores all dates/times in UTC. To ensure consistency and avoid timezone conversion bugs, **ALWAYS** use UTC methods when manipulating dates.

#### 1. Use UTC Methods for Time Setting
```typescript
// ✅ CORRECT: Use UTC methods
const startDate = new Date();
startDate.setUTCHours(0, 0, 0, 0);
endDate.setUTCHours(23, 59, 59, 999);

// ❌ WRONG: Local timezone methods cause timezone conversion issues
startDate.setHours(0, 0, 0, 0); // Creates dates in server's local timezone
endDate.setHours(23, 59, 59, 999);
```

#### 2. Use Date.UTC() for Date Construction with Time Components
```typescript
// ✅ CORRECT: Create dates in UTC
const date = new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));

// ❌ WRONG: Creates dates in local timezone
const date = new Date(year, month - 1, day, hours, minutes, seconds);
```

#### 3. Methods That Must Use UTC Versions
- `setHours()` → `setUTCHours()`
- `setMinutes()` → `setUTCMinutes()`
- `setSeconds()` → `setUTCSeconds()`
- `setMilliseconds()` → `setUTCMilliseconds()`
- `getHours()` → `getUTCHours()` (when comparing/storing)
- `getMinutes()` → `getUTCMinutes()` (when comparing/storing)
- `getSeconds()` → `getUTCSeconds()` (when comparing/storing)
- `getMilliseconds()` → `getUTCMilliseconds()` (when comparing/storing)

#### 4. Date Construction Patterns
```typescript
// ✅ CORRECT: For dates with time components
const date = new Date(Date.UTC(2025, 0, 15, 0, 0, 0)); // Jan 15, 2025 00:00:00 UTC

// ✅ CORRECT: For date-only operations (setDate is fine)
const date = new Date();
date.setDate(date.getDate() + 7); // Adding days is fine

// ✅ CORRECT: ISO string parsing (already UTC)
const date = new Date('2025-01-15T00:00:00Z');
```

#### 5. Why This Matters
- Database stores dates in UTC
- Server may run in different timezones (EAT, UTC, etc.)
- Using local timezone methods causes dates to shift when stored/retrieved
- Example: `setHours(0, 0, 0, 0)` in EAT (UTC+3) creates `21:00:00 UTC` the previous day

#### 6. Code Review Checklist
Before submitting code, verify:
- [ ] All `setHours()` calls use `setUTCHours()`
- [ ] All `setMinutes()` calls use `setUTCMinutes()`
- [ ] All `setSeconds()` calls use `setUTCSeconds()`
- [ ] All `setMilliseconds()` calls use `setUTCMilliseconds()`
- [ ] Date construction with time components uses `Date.UTC()`
- [ ] Date comparisons use UTC methods when appropriate

## Related Files
- `src/enums/error-codes.enum.ts` - Error code definitions
- `src/exceptions/validation.exception.ts` - Validation exception class
- `src/filters/global-exception.filter.ts` - Global error handling
- `docs/development/error-handling-guide.md` - Complete developer guide
- `docs/architecture/decisions/004-standardized-error-handling.md` - Architecture decision
